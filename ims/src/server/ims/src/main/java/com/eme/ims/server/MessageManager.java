package com.eme.ims.server;import java.io.FileOutputStream;import java.io.IOException;import java.nio.charset.CharacterCodingException;import java.nio.charset.Charset;import java.nio.charset.CharsetDecoder;import java.nio.charset.CharsetEncoder;import org.apache.mina.core.buffer.IoBuffer;import com.eme.ims.codec.Message;import com.eme.ims.codec.MsgProtocol;import com.eme.ims.utils.PropertyConfig;public enum MessageManager {		INSTANCE;	private CharsetEncoder encoder = Charset.forName("utf-8").newEncoder();	private CharsetDecoder decoder = Charset.forName("utf-8").newDecoder();		private static transient int DEFAULT_SIZE = 164;	 	public int getMessageSize(Message message) {		int messageSize = 0;		try {			String contents = message.getContents();			if (null != contents && contents.length()>0) {				byte[] bytes = message.getContents().getBytes("UTF-8");				messageSize = bytes.length;			}		} catch (Exception e) {			e.printStackTrace();		}		return DEFAULT_SIZE + messageSize;	}			public IoBuffer  getStreamBuffer(Message message) throws CharacterCodingException{				int capacity = this.getMessageSize(message);				IoBuffer buffer = IoBuffer.allocate(capacity+4);				buffer.putInt(capacity);		buffer.putString(message.getUid(), encoder);		buffer.putString(message.getFrom(), encoder);		buffer.putString(message.getTo(), encoder);		buffer.putString(message.getGroupId(), encoder);				buffer.putInt(message.getCommandId());		buffer.putInt(message.getType().intValue());		buffer.putInt(message.getError().intValue());		buffer.putInt(message.getStatus().intValue());		buffer.putInt(message.getDirection().intValue());				buffer.putString(message.getContents(), encoder);				return buffer;			}	    		public Message fromStream (IoBuffer buffer, int capacity, PropertyConfig config) throws CharacterCodingException {				Message message = new Message();				message.setUid(buffer.getString(36,decoder));		//System.out.println("uid:["+message.getUid()+"]");		message.setFrom(buffer.getString(36, decoder));		System.out.println("from:["+message.getFrom()+"]");				message.setTo(buffer.getString(36, decoder));		System.out.println("to:["+message.getTo()+"]");				message.setGroupId(buffer.getString(36, decoder));		System.out.println("group Id:["+message.getGroupId()+"]");						message.setCommandId(buffer.getInt());		System.out.println("command id:" + message.getCommandId().intValue());				message.setType(Integer.valueOf(buffer.getInt()).shortValue());		System.out.println("type:["+message.getType()+"]");				message.setError(Integer.valueOf(buffer.getInt()).shortValue());		System.out.println("ErrorId:["+message.getError()+"]");				message.setStatus(Integer.valueOf(buffer.getInt()).shortValue());		System.out.println("status:["+message.getStatus()+"]");				message.setDirection(Integer.valueOf(buffer.getInt()).shortValue());		System.out.println("direction:["+message.getDirection()+"]");				if (message.getType() == MsgProtocol.MsgType.VOICE) {			System.out.println("message type : voice");			if (message.getDirection() == MsgProtocol.MsgDirection.CLIENT_TO_SERVER) {				byte[] audio = new byte[capacity-164];				buffer.get(audio);				String path = config.getString("audio.folder");				String fileName = message.getUid()+".aac";			    try {			    	FileOutputStream fos = new FileOutputStream(path+fileName);	    			fos.write(audio, 0, audio.length);	    			fos.flush();	    			fos.close();					message.setContents("http://"+config.getString("server.host")+"/audio/"+fileName);					System.out.println(fileName); 				} catch (IOException e) {					System.out.println("failed to save file to disk.");				}			} else {				message.setContents(buffer.getString(decoder));				System.out.println("message:["+message.getContents()+"]");			}		} else {			message.setContents(buffer.getString(decoder));			System.out.println("message:["+message.getContents()+"]");		}				message.setEventTime(System.currentTimeMillis());		return message;	}	  }