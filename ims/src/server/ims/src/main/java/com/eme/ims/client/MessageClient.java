package com.eme.ims.client;import java.net.InetSocketAddress;import java.net.SocketAddress;import org.apache.mina.core.future.ConnectFuture;import org.apache.mina.core.service.IoHandlerAdapter;import org.apache.mina.core.session.IoSession;import org.apache.mina.filter.codec.ProtocolCodecFactory;import org.apache.mina.filter.codec.ProtocolCodecFilter;import org.apache.mina.filter.executor.ExecutorFilter;import org.apache.mina.filter.logging.LoggingFilter;import org.apache.mina.transport.socket.SocketSessionConfig;import org.apache.mina.transport.socket.nio.NioSocketConnector;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.eme.ims.codec.MessageCodecFactory;import com.eme.ims.utils.PropertyConfig;public class MessageClient {		private NioSocketConnector connector;	private IoHandlerAdapter handler = null;	private IoSession session = null;		private String host;	private int port;		private static Logger logger = LoggerFactory.getLogger(MessageClient.class);		public boolean connect(PropertyConfig config) {				boolean result = false;				ProtocolCodecFactory codecFactory = new MessageCodecFactory(config);				connector = new NioSocketConnector();		connector.setHandler(handler);		connector.getFilterChain().addLast("logger", new LoggingFilter());		connector.getFilterChain().addLast("codec", new ProtocolCodecFilter(codecFactory));		connector.getFilterChain().addLast("threadPool", new ExecutorFilter());		connector.getSessionConfig().setTcpNoDelay(true);				SocketSessionConfig socketSessionCfg = connector.getSessionConfig();		socketSessionCfg.setKeepAlive(true);		socketSessionCfg.setWriteTimeout(30);		socketSessionCfg.setBothIdleTime(60);				//logger.debug("we are ready to connnect to "+host +":"+ port);				try {			SocketAddress address = new InetSocketAddress(host, port);			ConnectFuture future = connector.connect(address);			future.awaitUninterruptibly(10000);			if (!future.isConnected())			{				logger.error("failed to connect to ["+host+":"+port+"]!");				return false;			}			session = future.getSession();			result = true;			logger.debug("connect to server successfully!");		} catch (Exception e) {			result = false;		}				return result;	}		public boolean sendMessage(Object message) {				boolean result = false;				if (this.sessionIsAvailable()) {			try {				session.write(message);				result = true;			} catch (Exception e) {				logger.warn("failed to send messsage: ["+message.toString()+"]");			}		}				return result;	}		public boolean disconnect() {				boolean result = false;				if (null != connector || connector.isActive()) {			connector.dispose();			result = true;		} 		logger.debug("disconnected.");				return result;	}	private boolean sessionIsAvailable()  {		boolean result = false;				if (null != session && session.isConnected()) {			logger.debug("session is available");			result = true;		} else {			logger.warn("session is not available.");		}				return result;	}	public String getHost() {		return host;	}	public void setHost(String host) {		this.host = host;	}	public int getPort() {		return port;	}	public void setPort(int port) {		this.port = port;	}	public IoHandlerAdapter getHandler() {		return handler;	}	public void setHandler(IoHandlerAdapter handler) {		this.handler = handler;	}}